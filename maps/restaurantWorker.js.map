{"version":3,"sources":["restaurantWorker.js"],"names":["importScripts","self","onmessage","msg","data","action","getRestaurants","filter","getRestaurant","id","getNeighborhoodsAndCuisines","getRestaurantReviews","DBHelper","then","dbRestaurants","console","log","length","filteredRestaurants","filterRestaurants","postMessage","retrieved","msgData","APIHelper","apiRestaurants","updatedRestaurants","updateRestaurants","restaurant","newRestaurant","updateRestaurant","restaurants","neighborhoodsAndCuisines","neighborhoods","extractNeighborhoods","cuisines","extractCuisines","newRestaurants","dbReviews","getReview","apiReviews","updatedReviews","updateReviewsDB","results","cuisine","r","cuisine_type","neighborhood","map","v","i","indexOf","apiRestaurant","restaurantFound","updatedAt","push","storeRestaurant","oldRestaurant","apiReview","reviewFound","dbReview","review","storeReview"],"mappings":"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","file":"../js/restaurantWorker.js","sourcesContent":["importScripts('/js/apihelper.js',\r\n\t'/js/dbhelper.js');\r\n/**\r\n * Handle message from  main thread\r\n * @param  {Message} msg Message from main thread\r\n */\r\nself.onmessage = msg => {\r\n\tconst data = msg.data;\r\n\tswitch(data.action){\r\n\t\tcase 'getRestaurants':\r\n\t\t\tgetRestaurants(data.filter);\r\n\t\t\tbreak;\r\n\t\tcase 'getRestaurant':\r\n\t\t\tgetRestaurant(data.id);\r\n\t\t\tbreak;\r\n\t\tcase 'getNeighborhoodsAndCuisines':\r\n\t\t\tgetNeighborhoodsAndCuisines();\r\n\t\t\tbreak;\r\n\t\tcase 'getRestaurantReviews':\r\n\t\t\tgetRestaurantReviews(data.id);\r\n\t\t\tbreak;\r\n\t}\r\n}\r\n\r\n/**\r\n * Fetch restaurants and update local db if out of date\r\n * @param  {Json} filter criteria to filter restaurants by before sending back to main thread\r\n */\r\ngetRestaurants = filter => {\r\n\tDBHelper.getRestaurant().then((dbRestaurants) => {\r\n\t\t\r\n\t\t// If restaurants are retrieved from the db filter them and send them to the main thread\r\n\t\tif(dbRestaurants){\r\n\t\t\t\r\n\t\t\tconsole.log(`${dbRestaurants.length} restaurants found in db`);\r\n\t\t\tconst filteredRestaurants = filterRestaurants(dbRestaurants, filter);\r\n\t\t\tself.postMessage({retrieved: 'restaurants', msgData: filteredRestaurants});\r\n\t\t}\r\n\r\n\t\tAPIHelper.getRestaurant().then(apiRestaurants => {\r\n\t\t\t\r\n\t\t\tconst updatedRestaurants = updateRestaurants(dbRestaurants, apiRestaurants);\r\n\r\n\t\t\tif(updatedRestaurants){\r\n\t\t\t\tconst filteredRestaurants = filterRestaurants(updatedRestaurants, filter);\r\n\t\t\t\tself.postMessage({retrieved: 'restaurants', msgData: filteredRestaurants});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t});\r\n}\r\n\r\n/**\r\n * Fetch a restaurant and update the local db if out of date\r\n * @param  {Int} id the id of the restaurant to fetch\r\n */\r\ngetRestaurant = id => {\r\n\tDBHelper.getRestaurant(id).then(restaurant =>{\r\n\r\n\t\t// If restaurant is retrieved from db then send it to the main thread\r\n\t\tif(restaurant){\r\n\t\t\tconsole.log(`Restaurant ${id} found in db`);\r\n\t\t\tself.postMessage({retrieved: 'restaurant', msgData: restaurant});\r\n\t\t}\r\n\r\n\t\tAPIHelper.getRestaurant(id).then(newRestaurant => {\r\n\t\t\tconst restaurantUpdated = updateRestaurant(restaurant, newRestaurant);\r\n\r\n\t\t\tif(restaurantUpdated){\r\n\t\t\t\tself.postMessage({retrieved: 'restaurant', msgData: newRestaurant});\r\n\t\t\t}\r\n\r\n\t\t})\r\n\t});\r\n}\r\n\r\n/**\r\n * Retrieve all neighborhoods and cuisines from restaurants and send them back to the main thread\r\n */\r\ngetNeighborhoodsAndCuisines = () => {\r\n\tDBHelper.getRestaurant().then(restaurants => {\r\n\t\tif(restaurants){\r\n\t\t\tconst neighborhoodsAndCuisines = {neighborhoods: extractNeighborhoods(restaurants), cuisines: extractCuisines(restaurants)};\r\n\t\t\tconsole.log(`Found ${neighborhoodsAndCuisines.neighborhoods.length} neighborhoods and ${neighborhoodsAndCuisines.cuisines.length} cuisines in db.`);\r\n\t\t\tself.postMessage({retrieved: 'neighborhoodsAndCuisines', msgData: neighborhoodsAndCuisines});\r\n\t\t}\r\n\r\n\t\tAPIHelper.getRestaurant().then(newRestaurants => {\r\n\r\n\t\t\tconst updatedRestaurants = updateRestaurants(restaurants, newRestaurants);\r\n\r\n\t\t\tif(updatedRestaurants){\r\n\t\t\t\tconst neighborhoodsAndCuisines = {neighborhoods: extractNeighborhoods(newRestaurants), cuisines: extractCuisines(newRestaurants)};\r\n\t\t\t\tconsole.log(`Found ${neighborhoodsAndCuisines.neighborhoods.length} neighborhoods and ${neighborhoodsAndCuisines.cuisines.length} cuisines from api.`);\r\n\t\t\t\tself.postMessage({retrieved: 'neighborhoodsAndCuisines', msgData: neighborhoodsAndCuisines});\r\n\t\t\t}\r\n\t\t});\r\n\t});\r\n}\r\n\r\ngetRestaurantReviews = id => {\r\n\tDBHelper.getRestaurantReviews(id).then(dbReviews => {\r\n\r\n\t\tif(dbReviews){\r\n\t\t\tconsole.log(`${dbReviews.length} reviews for restaurant ${id} found in db`);\r\n\r\n\t\t\tself.postMessage({retrieved: 'restaurantReviews', msgData: dbReviews});\r\n\t\t}\r\n\r\n\t\tAPIHelper.getReview(id, true).then(apiReviews => {\r\n\t\t\tconst updatedReviews = updateReviewsDB(dbReviews, apiReviews);\r\n\r\n\t\t\tif(updatedReviews){\r\n\t\t\t\tself.postMessage({retrieved: 'restaurantReviews', msgData: updatedReviews});\r\n\t\t\t}\r\n\t\t})\r\n\t})\r\n}\r\n\r\n/**\r\n * Filter restaurants by cuisine and neighborhood\r\n * @param  {Json} restaurants list of restaurants to filter\r\n * @param  {Json} filter      criteria to filter by\r\n */\r\nfilterRestaurants = (restaurants, filter) => {\r\n\tlet results = restaurants;\r\n\tif(filter.cuisine != 'all')\r\n\t\tresults = results.filter(r => r.cuisine_type == filter.cuisine);\r\n\tif(filter.neighborhood != 'all')\r\n\t\tresults = results.filter(r => r.neighborhood == filter.neighborhood);\r\n\tconsole.log(`${results.length} restaurants match filter`);\r\n\treturn results;\r\n}\r\n\r\n/**\r\n * Extract neighborhoods from restaurants\r\n * @param  {Json} restaurants Restaurants to extract neighborhoods from from\r\n * @return {String}             Array of all neighborhoods\r\n */\r\nextractNeighborhoods = restaurants => {\r\n\tconst neighborhoods = restaurants.map((v,i) => restaurants[i].neighborhood);\r\n\tconst uniqueNeighborhoods = neighborhoods.filter((v,i) => neighborhoods.indexOf(v) == i);\r\n\r\n\treturn uniqueNeighborhoods;\r\n}\r\n\r\n/**\r\n * Extract cuisines from restaurants\r\n * @param  {Json} restaurants Restaurants to extract cuisines from from\r\n * @return {String}             Array of all cuisines\r\n */\r\nextractCuisines = restaurants => {\r\n\tconst cuisines = restaurants.map((v,i) => restaurants[i].cuisine_type);\r\n\tconst uniqueCuisines = cuisines.filter((v,i) => cuisines.indexOf(v) == i);\r\n\r\n\treturn uniqueCuisines;\r\n}\r\n\r\n/**\r\n * Check if restaurants are out of date and if they are update the db\r\n * @param  {Json} dbRestaurants Restaurants retrieved from db\r\n * @param  {Json} apiRestaurants Restaurants retrieved from api\r\n * @return {Json}               Returns updatedRestaurants\r\n */\r\nupdateRestaurants = (dbRestaurants, apiRestaurants) => {\r\n\r\n\tlet updatedRestaurants = [];\r\n\r\n\t// If restaurants are retrieved from api check to see if they are newer than those in the db\r\n\tif(apiRestaurants){\r\n\r\n\t\tfor(apiRestaurant of apiRestaurants) {\r\n\t\t\tlet restaurantFound = false;\r\n\r\n\t\t\t// If there are no restaurants retrieved from the db then skip checking and add them to updatedRestaurants\r\n\t\t\tif(dbRestaurants){\r\n\t\t\t\tfor(restaurant of dbRestaurants) {\r\n\r\n\t\t\t\t\t// If restaurant is found then check to see if its up to date\r\n\t\t\t\t\tif(restaurant.id == apiRestaurant.id){\r\n\t\t\t\t\t\tif(restaurant.updatedAt >= apiRestaurant.updatedAt){\r\n\t\t\t\t\t\t\trestaurantFound = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// If updated restaurant isnt found add it to the list of restaurants to update\r\n\t\t\tif(!restaurantFound){\r\n\t\t\t\tupdatedRestaurants.push(apiRestaurant);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// If there are any outdated restaurants in the db update and return them\r\n\tif(updatedRestaurants.length != 0){\r\n\r\n\t\tconsole.log(`${updatedRestaurants.length} restaurants are outdated, updating...`);\r\n\r\n\t\tfor(restaurant of updatedRestaurants) {\r\n\t\t\tDBHelper.storeRestaurant(restaurant);\r\n\t\t}\r\n\r\n\t\treturn updatedRestaurants;\r\n\t}\r\n\r\n\treturn null;\r\n\r\n}\r\n\r\n/**\r\n * Check if oldRestaurant is out of date and if it is update the db\r\n * @param  {Json} oldRestaurant Restaurant retrieved from db\r\n * @param  {Json} newRestaurant Restaurant retrieved from api\r\n * @return {Boolean}               Returns true if oldRestaurant was out of date\r\n */\r\nupdateRestaurant = (oldRestaurant, newRestaurant) => {\r\n\t// If restaurant is retrieved from api check to see if its newer than the one in the db\r\n\tif(newRestaurant){\r\n\t\tlet updateRestaurant = true;\r\n\r\n\t\tif(oldRestaurant && (oldRestaurant.updatedAt >= newRestaurant.updatedAt)){\r\n\t\t\tupdateRestaurant = false;\r\n\t\t}\r\n\r\n\t\t// If restaurant is outdated then send it to the main thread and update the db\r\n\t\tif(updateRestaurant){\r\n\t\t\tconsole.log(`Restaurant ${newRestaurant.id} outdated, Updating...`);\r\n\t\t\tDBHelper.storeRestaurant(newRestaurant);\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n/**\r\n * Check if reviews are out of date and if they are update the db\r\n * @param  {Json} dbReviews Reviews retrieved from db\r\n * @param  {Json} apiReviews Reviews retrieved from api\r\n * @return {Array}               Returns updatedReviews\r\n */\r\nupdateReviewsDB = (dbReviews, apiReviews) => {\r\n\tlet updatedReviews = [];\r\n\r\n\t// If reviews are retrieved from api check to see if they are newer than those in the db\r\n\tif(apiReviews){\r\n\r\n\t\tfor(apiReview of apiReviews){\r\n\t\t\tlet reviewFound = false;\r\n\r\n\t\t\t// If there are no reviews retrieved from the db then skip checking and add them to updatedReviews\r\n\t\t\tif(dbReviews){\r\n\t\t\t\tfor(dbReview of dbReviews){\r\n\r\n\t\t\t\t\t// If review is found then check to see if its up to date\r\n\t\t\t\t\tif(dbReview.id == apiReview.id){\r\n\t\t\t\t\t\tif(dbReview.updatedAt >= apiReview.updatedAt){\r\n\t\t\t\t\t\t\treviewFound = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// If updated review isnt found add it to the list of reviews to update\r\n\t\t\tif(!reviewFound){\r\n\t\t\t\tupdatedReviews.push(apiReview);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// If there are any outdated reviews in the db update and return them\r\n\tif(updatedReviews != 0){\r\n\t\tconsole.log(`${updatedReviews.length} reviews are outdated, updating...`);\r\n\r\n\t\tfor(review of updatedReviews){\r\n\t\t\tDBHelper.storeReview(review);\r\n\t\t}\r\n\r\n\t\treturn updatedReviews;\r\n\t}\r\n\r\n\treturn null;\r\n\r\n}"]}