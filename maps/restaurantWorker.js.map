{"version":3,"sources":["restaurantWorker.js"],"names":["importScripts","self","onmessage","msg","data","action","getRestaurants","filter","getRestaurant","id","getNeighborhoodsAndCuisines","getRestaurantReviews","getReview","createReview","review","updateReview","deleteReview","setFavorite","state","DBHelper","then","dbRestaurants","console","log","length","filteredRestaurants","filterRestaurants","postMessage","retrieved","msgData","APIHelper","apiRestaurants","updatedRestaurants","updateRestaurants","restaurant","newRestaurant","updateRestaurant","restaurants","neighborhoodsAndCuisines","neighborhoods","extractNeighborhoods","cuisines","extractCuisines","newRestaurants","dbReviews","apiReviews","updatedReviews","updateReviewsDB","dbReview","apiReview","updateReviewDB","success","storeOperationToSync","mode","stateString","updateFavorite","results","cuisine","r","cuisine_type","neighborhood","map","v","i","indexOf","apiRestaurant","restaurantFound","updatedAt","push","storeRestaurant","oldRestaurant","reviewFound","storeReview"],"mappings":"AAAAA,cAAc,mBACb,mBAKDC,KAAKC,UAAYC,CAAAA,IAChB,MAAMC,EAAOD,EAAIC,KACjB,OAAOA,EAAKC,QACX,IAAK,iBACJC,eAAeF,EAAKG,QACpB,MACD,IAAK,gBACJC,cAAcJ,EAAKK,IACnB,MACD,IAAK,8BACJC,8BACA,MACD,IAAK,uBACJC,qBAAqBP,EAAKK,IAC1B,MACD,IAAK,YACJG,UAAUR,EAAKK,IACf,MACD,IAAK,eACJI,aAAaT,EAAKU,QAClB,MACD,IAAK,eACJC,aAAaX,EAAKK,GAAIL,EAAKU,QAC3B,MACD,IAAK,eACJE,aAAaZ,EAAKK,IAClB,MACD,IAAK,cACJQ,YAAYb,EAAKK,GAAIL,EAAKc,UAS7BZ,eAAiBC,CAAAA,IAChBY,SAASX,gBAAgBY,KAAMC,IAG9B,GAAGA,EAAc,CAEhBC,QAAQC,OAAOF,EAAcG,kCAC7B,MAAMC,EAAsBC,kBAAkBL,EAAed,GAC7DN,KAAK0B,YAAY,CAACC,UAAW,cAAeC,QAASJ,IAGtDK,UAAUtB,gBAAgBY,KAAKW,IAE9B,MAAMC,EAAqBC,kBAAkBZ,EAAeU,GAE5D,GAAGC,EAAmB,CACrB,MAAMP,EAAsBC,kBAAkBM,EAAoBzB,GAClEN,KAAK0B,YAAY,CAACC,UAAW,cAAeC,QAASJ,WAWzDjB,cAAgBC,CAAAA,IACfU,SAASX,cAAcC,GAAIW,KAAKc,IAG5BA,IACFZ,QAAQC,kBAAkBd,iBAC1BR,KAAK0B,YAAY,CAACC,UAAW,aAAcC,QAASK,KAGrDJ,UAAUtB,cAAcC,GAAIW,KAAKe,IACNC,iBAAiBF,EAAYC,IAGtDlC,KAAK0B,YAAY,CAACC,UAAW,aAAcC,QAASM,UAUxDzB,4BAA8B,MAC7BS,SAASX,gBAAgBY,KAAKiB,IAC7B,GAAGA,EAAY,CACd,MAAMC,EAA2B,CAACC,cAAeC,qBAAqBH,GAAcI,SAAUC,gBAAgBL,IAC9Gf,QAAQC,aAAae,EAAyBC,cAAcf,4BAA4Bc,EAAyBG,SAASjB,0BAC1HvB,KAAK0B,YAAY,CAACC,UAAW,2BAA4BC,QAASS,IAGnER,UAAUtB,gBAAgBY,KAAKuB,IAI9B,GAF2BV,kBAAkBI,EAAaM,GAEpC,CACrB,MAAML,EAA2B,CAACC,cAAeC,qBAAqBG,GAAiBF,SAAUC,gBAAgBC,IACjHrB,QAAQC,aAAae,EAAyBC,cAAcf,4BAA4Bc,EAAyBG,SAASjB,6BAC1HvB,KAAK0B,YAAY,CAACC,UAAW,2BAA4BC,QAASS,WAUtE3B,qBAAuBF,CAAAA,IACtBU,SAASR,qBAAqBF,GAAIW,KAAKwB,IAEnCA,IACFtB,QAAQC,OAAOqB,EAAUpB,iCAAiCf,iBAE1DR,KAAK0B,YAAY,CAACC,UAAW,oBAAqBC,QAASe,KAG5Dd,UAAUlB,UAAUH,GAAI,GAAMW,KAAKyB,IAClC,MAAMC,EAAiBC,gBAAgBH,EAAWC,GAE/CC,GACF7C,KAAK0B,YAAY,CAACC,UAAW,oBAAqBC,QAASiB,UAU/DlC,UAAYH,CAAAA,IACXU,SAASP,UAAUH,GAAIW,KAAK4B,IAExBA,IACF1B,QAAQC,cAAcd,iBAEtBR,KAAK0B,YAAY,CAACC,UAAW,SAAUC,QAASmB,KAGjDlB,UAAUlB,UAAUH,GAAIW,KAAK6B,IACNC,eAAeF,EAAUC,IAG9ChD,KAAK0B,YAAY,CAACC,UAAW,SAAUC,QAAQoB,UAUnDpC,aAAeC,CAAAA,IACdgB,UAAUjB,aAAaC,GAAQM,KAAK+B,IAChCA,GACF7B,QAAQC,IAAI,gCACZtB,KAAK0B,YAAY,CAACC,UAAW,eAAgBC,SAAQ,MAErDP,QAAQC,IAAI,kFACZJ,SAASiC,qBAAqB,CAACC,KAAM,SAAUvC,OAAQA,IACvDb,KAAK0B,YAAY,CAACC,UAAW,eAAgBC,SAAQ,SAYxDd,aAAe,EAACN,EAAIK,KACnBgB,UAAUf,aAAaN,EAAIK,GAAQM,KAAK+B,IACpCA,GACF7B,QAAQC,IAAI,gCACZtB,KAAK0B,YAAY,CAACC,UAAW,eAAgBC,SAAQ,MAErDP,QAAQC,IAAI,kFACZJ,SAASiC,qBAAqB,CAACC,KAAM,SAAU5C,GAAIA,EAAIK,OAAQA,IAC/Db,KAAK0B,YAAY,CAACC,UAAW,eAAgBC,SAAQ,SASxDb,aAAeP,CAAAA,IACdU,SAASH,aAAaP,GAAIW,KAAK,KAC9BE,QAAQC,IAAI,0BAEZO,UAAUd,aAAaP,GAAIW,KAAK+B,IAC5BA,GACF7B,QAAQC,IAAI,wCACZtB,KAAK0B,YAAY,CAACC,UAAW,SAAUC,SAAS,MAEhDP,QAAQC,IAAI,qEACZJ,SAASiC,qBAAqB,CAACC,KAAM,SAAU5C,GAAGA,IAClDR,KAAK0B,YAAY,CAACC,UAAW,SAAUC,SAAS,WAWpDZ,YAAc,EAACR,EAAIS,KAClBC,SAASF,YAAYR,EAAIS,GAAOE,KAAK,KACpC,MAAMkC,EAAc,EAAS,YAAY,cACzChC,QAAQC,kBAAkBd,KAAM6C,KAEhCxB,UAAUyB,eAAe9C,EAAIS,GAAOE,KAAK+B,IACrCA,GACF7B,QAAQC,kBAAkB+B,YAC1BrD,KAAK0B,YAAY,CAACC,UAAW,YAAaC,SAAS,MAEnDP,QAAQC,IAAI,oEACZJ,SAASiC,qBAAqB,CAACC,KAAM,WAAY5C,GAAGA,EAAIS,MAAMA,IAC9DjB,KAAK0B,YAAY,CAACC,UAAW,YAAaC,SAAS,WAWvDH,kBAAoB,EAACW,EAAa9B,KACjC,IAAIiD,EAAUnB,EAMd,MALqB,OAAlB9B,EAAOkD,UACTD,EAAUA,EAAQjD,OAAOmD,GAAKA,EAAEC,cAAgBpD,EAAOkD,UAC9B,OAAvBlD,EAAOqD,eACTJ,EAAUA,EAAQjD,OAAOmD,GAAKA,EAAEE,cAAgBrD,EAAOqD,eACxDtC,QAAQC,OAAOiC,EAAQhC,mCAChBgC,IAQRhB,qBAAuBH,CAAAA,IACtB,MAAME,EAAgBF,EAAYwB,IAAI,CAACC,EAAEC,IAAM1B,EAAY0B,GAAGH,cAG9D,OAF4BrB,EAAchC,OAAO,CAACuD,EAAEC,IAAMxB,EAAcyB,QAAQF,IAAMC,KAUvFrB,gBAAkBL,CAAAA,IACjB,MAAMI,EAAWJ,EAAYwB,IAAI,CAACC,EAAEC,IAAM1B,EAAY0B,GAAGJ,cAGzD,OAFuBlB,EAASlC,OAAO,CAACuD,EAAEC,IAAMtB,EAASuB,QAAQF,IAAMC,KAWxE9B,kBAAoB,EAACZ,EAAeU,KAEnC,IAAIC,EAAqB,GAGzB,GAAGD,EAEF,IAAIkC,iBAAiBlC,EAAgB,CACpC,IAAImC,GAAkB,EAGtB,GAAG7C,EACF,IAAIa,cAAcb,EAGjB,GAAGa,WAAWzB,IAAMwD,cAAcxD,IAC9ByB,WAAWiC,WAAaF,cAAcE,UAAU,CAClDD,GAAkB,EAClB,MAQAA,GACHlC,EAAmBoC,KAAKH,eAM3B,GAAgC,GAA7BjC,EAAmBR,OAAY,CAIjC,IAAIU,cAFJZ,QAAQC,OAAOS,EAAmBR,gDAEhBQ,GACjBb,SAASkD,gBAAgBnC,YAG1B,OAAOF,EAGR,OAAO,OAURI,iBAAmB,EAACkC,EAAenC,KAElC,GAAGA,EAAc,CAChB,IAAIC,GAAmB,EAOvB,OALGkC,GAAkBA,EAAcH,WAAahC,EAAcgC,YAC7D/B,GAAmB,KAIjBA,IACFd,QAAQC,kBAAkBY,EAAc1B,4BACxCU,SAASkD,gBAAgBlC,IAElB,MAaVY,gBAAkB,EAACH,EAAWC,KAC7B,IAAIC,EAAiB,GAGrB,GAAGD,EAEF,IAAII,aAAaJ,EAAW,CAC3B,IAAI0B,GAAc,EAGlB,GAAG3B,EACF,IAAII,YAAYJ,EAGf,GAAGI,SAASvC,IAAMwC,UAAUxC,IACxBuC,SAASmB,WAAalB,UAAUkB,UAAU,CAC5CI,GAAc,EACd,MAQAA,GACHzB,EAAesB,KAAKnB,WAOvB,GAAqB,GAAlBH,EAAoB,CAGtB,IAAIhC,UAFJQ,QAAQC,OAAOuB,EAAetB,4CAEhBsB,GACb3B,SAASqD,YAAY1D,QAGtB,OAAOgC,EAGR,OAAO,OAWRI,eAAiB,EAACF,EAAUC,KAE3B,GAAGA,EAAU,CACZ,IAAIlC,GAAe,EAMnB,OAJGiC,GAAaA,EAASmB,WAAalB,EAAUkB,YAC/CpD,GAAe,KAGbA,IACFO,QAAQC,cAAc0B,EAAUxC,4BAChCU,SAASqD,YAAYvB,IAEd","file":"../js/restaurantWorker.js","sourcesContent":["importScripts('/js/apihelper.js',\r\n\t'/js/dbhelper.js');\r\n/**\r\n * Handle message from  main thread\r\n * @param  {Message} msg Message from main thread\r\n */\r\nself.onmessage = msg => {\r\n\tconst data = msg.data;\r\n\tswitch(data.action){\r\n\t\tcase 'getRestaurants':\r\n\t\t\tgetRestaurants(data.filter);\r\n\t\t\tbreak;\r\n\t\tcase 'getRestaurant':\r\n\t\t\tgetRestaurant(data.id);\r\n\t\t\tbreak;\r\n\t\tcase 'getNeighborhoodsAndCuisines':\r\n\t\t\tgetNeighborhoodsAndCuisines();\r\n\t\t\tbreak;\r\n\t\tcase 'getRestaurantReviews':\r\n\t\t\tgetRestaurantReviews(data.id);\r\n\t\t\tbreak;\r\n\t\tcase 'getReview':\r\n\t\t\tgetReview(data.id);\r\n\t\t\tbreak;\r\n\t\tcase 'createReview':\r\n\t\t\tcreateReview(data.review);\r\n\t\t\tbreak;\r\n\t\tcase 'updateReview':\r\n\t\t\tupdateReview(data.id, data.review);\r\n\t\t\tbreak;\r\n\t\tcase 'deleteReview':\r\n\t\t\tdeleteReview(data.id);\r\n\t\t\tbreak;\r\n\t\tcase 'setFavorite':\r\n\t\t\tsetFavorite(data.id, data.state);\r\n\t\t\tbreak;\r\n\t}\r\n}\r\n\r\n/**\r\n * Fetch restaurants and update local db if out of date\r\n * @param  {Json} filter criteria to filter restaurants by before sending back to main thread\r\n */\r\ngetRestaurants = filter => {\r\n\tDBHelper.getRestaurant().then((dbRestaurants) => {\r\n\t\t\r\n\t\t// If restaurants are retrieved from the db filter them and send them to the main thread\r\n\t\tif(dbRestaurants){\r\n\t\t\t\r\n\t\t\tconsole.log(`${dbRestaurants.length} restaurants found in db`);\r\n\t\t\tconst filteredRestaurants = filterRestaurants(dbRestaurants, filter);\r\n\t\t\tself.postMessage({retrieved: 'restaurants', msgData: filteredRestaurants});\r\n\t\t}\r\n\r\n\t\tAPIHelper.getRestaurant().then(apiRestaurants => {\r\n\t\t\t\r\n\t\t\tconst updatedRestaurants = updateRestaurants(dbRestaurants, apiRestaurants);\r\n\r\n\t\t\tif(updatedRestaurants){\r\n\t\t\t\tconst filteredRestaurants = filterRestaurants(updatedRestaurants, filter);\r\n\t\t\t\tself.postMessage({retrieved: 'restaurants', msgData: filteredRestaurants});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t});\r\n}\r\n\r\n/**\r\n * Fetch a restaurant and update the local db if out of date\r\n * @param  {Int} id the id of the restaurant to fetch\r\n */\r\ngetRestaurant = id => {\r\n\tDBHelper.getRestaurant(id).then(restaurant =>{\r\n\r\n\t\t// If restaurant is retrieved from db then send it to the main thread\r\n\t\tif(restaurant){\r\n\t\t\tconsole.log(`Restaurant ${id} found in db`);\r\n\t\t\tself.postMessage({retrieved: 'restaurant', msgData: restaurant});\r\n\t\t}\r\n\r\n\t\tAPIHelper.getRestaurant(id).then(newRestaurant => {\r\n\t\t\tconst restaurantUpdated = updateRestaurant(restaurant, newRestaurant);\r\n\r\n\t\t\tif(restaurantUpdated){\r\n\t\t\t\tself.postMessage({retrieved: 'restaurant', msgData: newRestaurant});\r\n\t\t\t}\r\n\r\n\t\t})\r\n\t});\r\n}\r\n\r\n/**\r\n * Retrieve all neighborhoods and cuisines from restaurants and send them back to the main thread\r\n */\r\ngetNeighborhoodsAndCuisines = () => {\r\n\tDBHelper.getRestaurant().then(restaurants => {\r\n\t\tif(restaurants){\r\n\t\t\tconst neighborhoodsAndCuisines = {neighborhoods: extractNeighborhoods(restaurants), cuisines: extractCuisines(restaurants)};\r\n\t\t\tconsole.log(`Found ${neighborhoodsAndCuisines.neighborhoods.length} neighborhoods and ${neighborhoodsAndCuisines.cuisines.length} cuisines in db.`);\r\n\t\t\tself.postMessage({retrieved: 'neighborhoodsAndCuisines', msgData: neighborhoodsAndCuisines});\r\n\t\t}\r\n\r\n\t\tAPIHelper.getRestaurant().then(newRestaurants => {\r\n\r\n\t\t\tconst updatedRestaurants = updateRestaurants(restaurants, newRestaurants);\r\n\r\n\t\t\tif(updatedRestaurants){\r\n\t\t\t\tconst neighborhoodsAndCuisines = {neighborhoods: extractNeighborhoods(newRestaurants), cuisines: extractCuisines(newRestaurants)};\r\n\t\t\t\tconsole.log(`Found ${neighborhoodsAndCuisines.neighborhoods.length} neighborhoods and ${neighborhoodsAndCuisines.cuisines.length} cuisines from api.`);\r\n\t\t\t\tself.postMessage({retrieved: 'neighborhoodsAndCuisines', msgData: neighborhoodsAndCuisines});\r\n\t\t\t}\r\n\t\t});\r\n\t});\r\n}\r\n\r\n/**\r\n * Retrieve all reviews for a restaurant\r\n * @param  {int} id Id of restaurant\r\n */\r\ngetRestaurantReviews = id => {\r\n\tDBHelper.getRestaurantReviews(id).then(dbReviews => {\r\n\r\n\t\tif(dbReviews){\r\n\t\t\tconsole.log(`${dbReviews.length} reviews for restaurant ${id} found in db`);\r\n\r\n\t\t\tself.postMessage({retrieved: 'restaurantReviews', msgData: dbReviews});\r\n\t\t}\r\n\r\n\t\tAPIHelper.getReview(id, true).then(apiReviews => {\r\n\t\t\tconst updatedReviews = updateReviewsDB(dbReviews, apiReviews);\r\n\r\n\t\t\tif(updatedReviews){\r\n\t\t\t\tself.postMessage({retrieved: 'restaurantReviews', msgData: updatedReviews});\r\n\t\t\t}\r\n\t\t})\r\n\t})\r\n}\r\n\r\n/**\r\n * Retrieve review\r\n * @param  {int} id Id of review to retrieve\r\n */\r\ngetReview = id => {\r\n\tDBHelper.getReview(id).then(dbReview => {\r\n\r\n\t\tif(dbReview){\r\n\t\t\tconsole.log(`Review ${id} found in db`);\r\n\r\n\t\t\tself.postMessage({retrieved: 'review', msgData: dbReview});\r\n\t\t}\r\n\r\n\t\tAPIHelper.getReview(id).then(apiReview => {\r\n\t\t\tconst updatedReview = updateReviewDB(dbReview, apiReview);\r\n\r\n\t\t\tif(updatedReview){\r\n\t\t\t\tself.postMessage({retrieved: 'review', msgData:apiReview});\r\n\t\t\t}\r\n\t\t})\r\n\t})\r\n}\r\n\r\n/**\r\n * Upload a review to api or store it for upload when reconnected\r\n * @param  {Json} review Review to create\r\n */\r\ncreateReview = review => {\r\n\tAPIHelper.createReview(review).then(success => {\r\n\t\tif(success){\r\n\t\t\tconsole.log('Review successfully uploaded');\r\n\t\t\tself.postMessage({retrieved: 'uploadReview', msgData:true})\r\n\t\t}else{\r\n\t\t\tconsole.log('Unable to upload review, storing locally until connection is re-established...');\r\n\t\t\tDBHelper.storeOperationToSync({mode: 'create', review: review});\r\n\t\t\tself.postMessage({retrieved: 'uploadReview', msgData:false});\r\n\t\t}\r\n\t})\r\n}\r\n\r\n//TODO: add index to db for created/updated fix updates being creates\r\n\r\n/**\r\n * Update a review in api or store it for upload when reconnected\r\n * @param {Int} id Id of the review to update\r\n * @param  {Json} review Review to create\r\n */\r\nupdateReview = (id, review) => {\r\n\tAPIHelper.updateReview(id, review).then(success => {\r\n\t\tif(success){\r\n\t\t\tconsole.log('Review successfully uploaded');\r\n\t\t\tself.postMessage({retrieved: 'uploadReview', msgData:true})\r\n\t\t}else{\r\n\t\t\tconsole.log('Unable to upload review, storing locally until connection is re-established...');\r\n\t\t\tDBHelper.storeOperationToSync({mode: 'update', id: id, review: review});\r\n\t\t\tself.postMessage({retrieved: 'uploadReview', msgData:false});\r\n\t\t}\r\n\t})\r\n}\r\n\r\n/**\r\n * Delete review or note it for deletion when reconnected\r\n * @param  {int} id id of the review to delete\r\n */\r\ndeleteReview = id => {\r\n\tDBHelper.deleteReview(id).then(() =>{\r\n\t\tconsole.log('Review deleted from db');\r\n\r\n\t\tAPIHelper.deleteReview(id).then(success => {\r\n\t\t\tif(success){\r\n\t\t\t\tconsole.log('Review successfully deleted from api');\r\n\t\t\t\tself.postMessage({retrieved: 'delete', msgData: true});\r\n\t\t\t}else{\r\n\t\t\t\tconsole.log('Unable to delete review from api, will try again when reconnected');\r\n\t\t\t\tDBHelper.storeOperationToSync({mode: 'delete', id:id});\r\n\t\t\t\tself.postMessage({retrieved: 'delete', msgData: false});\r\n\t\t\t}\r\n\t\t})\r\n\t})\r\n}\r\n\r\n/**\r\n * set restaurant favorite state\r\n * @param {int} id    id of restaurant to update\r\n * @param {Boolean} state true to favorite restaurant false to unfavorite\r\n */\r\nsetFavorite = (id, state) => {\r\n\tDBHelper.setFavorite(id, state).then(() => {\r\n\t\tconst stateString = (state)? 'favorited':'unfavorited';\r\n\t\tconsole.log(`Restaurant ${id} ${stateString}`);\r\n\r\n\t\tAPIHelper.updateFavorite(id, state).then(success =>{\r\n\t\t\tif(success){\r\n\t\t\t\tconsole.log(`Restaurant ${stateString} in api`);\r\n\t\t\t\tself.postMessage({retrieved: 'favorited', msgData: true});\r\n\t\t\t}else{\r\n\t\t\t\tconsole.log('Unable to update favorite in api will try again when reconnected');\r\n\t\t\t\tDBHelper.storeOperationToSync({mode: 'favorite', id:id, state:state});\r\n\t\t\t\tself.postMessage({retrieved: 'favorited', msgData: false});\r\n\t\t\t}\r\n\t\t})\r\n\t})\r\n}\r\n\r\n/**\r\n * Filter restaurants by cuisine and neighborhood\r\n * @param  {Json} restaurants list of restaurants to filter\r\n * @param  {Json} filter      criteria to filter by\r\n */\r\nfilterRestaurants = (restaurants, filter) => {\r\n\tlet results = restaurants;\r\n\tif(filter.cuisine != 'all')\r\n\t\tresults = results.filter(r => r.cuisine_type == filter.cuisine);\r\n\tif(filter.neighborhood != 'all')\r\n\t\tresults = results.filter(r => r.neighborhood == filter.neighborhood);\r\n\tconsole.log(`${results.length} restaurants match filter`);\r\n\treturn results;\r\n}\r\n\r\n/**\r\n * Extract neighborhoods from restaurants\r\n * @param  {Json} restaurants Restaurants to extract neighborhoods from from\r\n * @return {String}             Array of all neighborhoods\r\n */\r\nextractNeighborhoods = restaurants => {\r\n\tconst neighborhoods = restaurants.map((v,i) => restaurants[i].neighborhood);\r\n\tconst uniqueNeighborhoods = neighborhoods.filter((v,i) => neighborhoods.indexOf(v) == i);\r\n\r\n\treturn uniqueNeighborhoods;\r\n}\r\n\r\n/**\r\n * Extract cuisines from restaurants\r\n * @param  {Json} restaurants Restaurants to extract cuisines from from\r\n * @return {String}             Array of all cuisines\r\n */\r\nextractCuisines = restaurants => {\r\n\tconst cuisines = restaurants.map((v,i) => restaurants[i].cuisine_type);\r\n\tconst uniqueCuisines = cuisines.filter((v,i) => cuisines.indexOf(v) == i);\r\n\r\n\treturn uniqueCuisines;\r\n}\r\n\r\n/**\r\n * Check if restaurants are out of date and if they are update the db\r\n * @param  {Json} dbRestaurants Restaurants retrieved from db\r\n * @param  {Json} apiRestaurants Restaurants retrieved from api\r\n * @return {Json}               Returns updatedRestaurants\r\n */\r\nupdateRestaurants = (dbRestaurants, apiRestaurants) => {\r\n\r\n\tlet updatedRestaurants = [];\r\n\r\n\t// If restaurants are retrieved from api check to see if they are newer than those in the db\r\n\tif(apiRestaurants){\r\n\r\n\t\tfor(apiRestaurant of apiRestaurants) {\r\n\t\t\tlet restaurantFound = false;\r\n\r\n\t\t\t// If there are no restaurants retrieved from the db then skip checking and add them to updatedRestaurants\r\n\t\t\tif(dbRestaurants){\r\n\t\t\t\tfor(restaurant of dbRestaurants) {\r\n\r\n\t\t\t\t\t// If restaurant is found then check to see if its up to date\r\n\t\t\t\t\tif(restaurant.id == apiRestaurant.id){\r\n\t\t\t\t\t\tif(restaurant.updatedAt >= apiRestaurant.updatedAt){\r\n\t\t\t\t\t\t\trestaurantFound = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// If updated restaurant isnt found add it to the list of restaurants to update\r\n\t\t\tif(!restaurantFound){\r\n\t\t\t\tupdatedRestaurants.push(apiRestaurant);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// If there are any outdated restaurants in the db update and return them\r\n\tif(updatedRestaurants.length != 0){\r\n\r\n\t\tconsole.log(`${updatedRestaurants.length} restaurants are outdated, updating...`);\r\n\r\n\t\tfor(restaurant of updatedRestaurants) {\r\n\t\t\tDBHelper.storeRestaurant(restaurant);\r\n\t\t}\r\n\r\n\t\treturn updatedRestaurants;\r\n\t}\r\n\r\n\treturn null;\r\n\r\n}\r\n\r\n/**\r\n * Check if oldRestaurant is out of date and if it is update the db\r\n * @param  {Json} oldRestaurant Restaurant retrieved from db\r\n * @param  {Json} newRestaurant Restaurant retrieved from api\r\n * @return {Boolean}               Returns true if oldRestaurant was out of date\r\n */\r\nupdateRestaurant = (oldRestaurant, newRestaurant) => {\r\n\t// If restaurant is retrieved from api check to see if its newer than the one in the db\r\n\tif(newRestaurant){\r\n\t\tlet updateRestaurant = true;\r\n\r\n\t\tif(oldRestaurant && (oldRestaurant.updatedAt >= newRestaurant.updatedAt)){\r\n\t\t\tupdateRestaurant = false;\r\n\t\t}\r\n\r\n\t\t// If restaurant is outdated then send it to the main thread and update the db\r\n\t\tif(updateRestaurant){\r\n\t\t\tconsole.log(`Restaurant ${newRestaurant.id} outdated, Updating...`);\r\n\t\t\tDBHelper.storeRestaurant(newRestaurant);\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n/**\r\n * Check if reviews are out of date and if they are update the db\r\n * @param  {Json} dbReviews Reviews retrieved from db\r\n * @param  {Json} apiReviews Reviews retrieved from api\r\n * @return {Array}               Returns updatedReviews\r\n */\r\nupdateReviewsDB = (dbReviews, apiReviews) => {\r\n\tlet updatedReviews = [];\r\n\r\n\t// If reviews are retrieved from api check to see if they are newer than those in the db\r\n\tif(apiReviews){\r\n\r\n\t\tfor(apiReview of apiReviews){\r\n\t\t\tlet reviewFound = false;\r\n\r\n\t\t\t// If there are no reviews retrieved from the db then skip checking and add them to updatedReviews\r\n\t\t\tif(dbReviews){\r\n\t\t\t\tfor(dbReview of dbReviews){\r\n\r\n\t\t\t\t\t// If review is found then check to see if its up to date\r\n\t\t\t\t\tif(dbReview.id == apiReview.id){\r\n\t\t\t\t\t\tif(dbReview.updatedAt >= apiReview.updatedAt){\r\n\t\t\t\t\t\t\treviewFound = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// If updated review isnt found add it to the list of reviews to update\r\n\t\t\tif(!reviewFound){\r\n\t\t\t\tupdatedReviews.push(apiReview);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// If there are any outdated reviews in the db update and return them\r\n\tif(updatedReviews != 0){\r\n\t\tconsole.log(`${updatedReviews.length} reviews are outdated, updating...`);\r\n\r\n\t\tfor(review of updatedReviews){\r\n\t\t\tDBHelper.storeReview(review);\r\n\t\t}\r\n\r\n\t\treturn updatedReviews;\r\n\t}\r\n\r\n\treturn null;\r\n\r\n}\r\n\r\n\r\n/**\r\n * Check if review is out of date and if it is update the db\r\n * @param  {Json} dbReview Review retrieved from db\r\n * @param  {Json} apiReview Review retrieved from api\r\n * @return {Boolean}               Returns true if dbReview was out of date\r\n */\r\nupdateReviewDB = (dbReview, apiReview) => {\r\n\r\n\tif(apiReview){\r\n\t\tlet updateReview = true;\r\n\r\n\t\tif(dbReview && (dbReview.updatedAt >= apiReview.updatedAt)){\r\n\t\t\tupdateReview = false;\r\n\t\t}\r\n\r\n\t\tif(updateReview){\r\n\t\t\tconsole.log(`Review ${apiReview.id} outdated, Updating...`);\r\n\t\t\tDBHelper.storeReview(apiReview);\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n}"]}