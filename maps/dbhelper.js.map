{"version":3,"sources":["dbhelper.js"],"names":["importScripts","restaurantDb","idb","open","db","oldVersion","createObjectStore","keyPath","transaction","objectStore","createIndex","autoIncrement","DBHelper","[object Object]","id","then","restaurantStore","response","get","Number","getAll","catch","error","console","restaurant","tx","put","complete","state","this","getRestaurant","is_favorite","storeRestaurant","reviewStore","restaurantId","index","keyVals","iterateCursor","cursor","log","primaryKey","value","push","key","continue","review","delete","add"],"mappings":"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","file":"../js/dbhelper.js","sourcesContent":["importScripts('https://rawgit.com/jakearchibald/idb/master/lib/idb.js')\r\n\r\nvar restaurantDb = idb.open('restaurants-db', 5, db => {\r\n  switch(db.oldVersion){\r\n    case 0:\r\n    \tdb.createObjectStore('restaurant', {keyPath: 'id'});\r\n    case 1:\r\n    \tdb.createObjectStore('review', {keyPath: 'id'});\r\n    case 2:\r\n    \tconst reviewStore = db.transaction.objectStore('review');\r\n    \treviewStore.createIndex('restaurant', 'restaurant_id');\r\n    case 3:\r\n    \tdb.createObjectStore('unsynced', {autoIncrement: true});\r\n    case 4:\r\n    \tconst unsyncedStore = db.transaction.objectStore('unsynced');\r\n    \tunsyncedStore.createIndex('mode', 'mode');\r\n  }\r\n});\r\n\r\nclass DBHelper {\r\n\r\n\t/**\r\n\t * retrieve restaurants from db\r\n\t * @param  {Int} id id of restaurant to retrieve, if null all restaurants will be retrieved\r\n\t * @return {Promise}    Will resolve to an array of retrieved restaurants\r\n\t */\r\n\tstatic getRestaurant(id = 0) {\r\n\t\treturn restaurantDb.then(db => {\r\n\t\t\tconst tx = db.transaction('restaurant');\r\n\t\t\tconst restaurantStore = tx.objectStore('restaurant');\r\n\t\t\tlet response;\r\n\t\t\tif(id != 0)\r\n\t\t\t\tresponse = restaurantStore.get(Number(id));\r\n\t\t\telse\r\n\t\t\t\tresponse = restaurantStore.getAll();\r\n\t\t\treturn response;\r\n\t\t}).catch(error => {\r\n\t\t\tconsole.error(error);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * update restaurant in db\r\n\t * @param  {Json} restaurant The restaurant data in json\r\n\t * @return {Promise}            Resolves if restaurant is successfully updated\r\n\t */\r\n\tstatic storeRestaurant(restaurant){\r\n\t\treturn restaurantDb.then(db => {\r\n\t\t\tconst tx = db.transaction('restaurant', 'readwrite');\r\n\t\t\tconst restaurantStore = tx.objectStore('restaurant');\r\n\t\t\trestaurantStore.put(restaurant);\r\n\t\t\treturn tx.complete;\r\n\t\t}).catch(error => {\r\n\t\t\tconsole.error(error);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * set restaurant favorite state\r\n\t * @param {int} id    id of restaurant to update\r\n\t * @param {Boolean} state true to favorite restaurant false to unfavorite\r\n\t * @return {Promise}            Resolves if restaurant is successfully updated\r\n\t */\r\n\tstatic setFavorite(id, state){\r\n\t\treturn this.getRestaurant(id).then(restaurant => {\r\n\t\t\trestaurant.is_favorite = state;\r\n\t\t\treturn this.storeRestaurant(restaurant);\r\n\t\t});\r\n\t}\r\n\t\r\n\t/**\r\n\t * retrieve reviews from db\r\n\t * @param  {Number} id id of review to retrieve\r\n\t * @return {Promise}    promise that will resolve to review json from db\r\n\t */\r\n\tstatic getReview(id = 0){\r\n\t\treturn restaurantDb.then(db => {\r\n\t\t\tconst tx = db.transaction('review');\r\n\t\t\tconst reviewStore = tx.objectStore('review');\r\n\t\t\tlet response;\r\n\t\t\tif(id != 0)\r\n\t\t\t\tresponse = reviewStore.get(Number(id));\r\n\t\t\telse\r\n\t\t\t\tresponse = reviewStore.getAll();\r\n\t\t\treturn response;\r\n\t\t}).catch(error => {\r\n\t\t\tconsole.error(error);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * retrieve reviews for restaurant\r\n\t * @param  {[type]} restaurantId id of restaurant to retrieve reviews for\r\n\t * @return {Promise}    promise that will resolve to restaurant review json from db\r\n\t */\r\n\tstatic getRestaurantReviews(restaurantId){\r\n\t\treturn restaurantDb.then(db => {\r\n\t\t\tconst tx = db.transaction('review');\r\n\t\t\tconst reviewStore = tx.objectStore('review');\r\n\t\t\tconst restaurantReviews = reviewStore.index('restaurant');\r\n\r\n\t\t\treturn restaurantReviews.getAll(Number(restaurantId));\r\n\t\t}).catch(error => {\r\n\t\t\tconsole.error(error);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * retrieve unsynced reviews\r\n\t * Thanks to JaromandaX for helping solve this issue in \r\n\t * https://stackoverflow.com/questions/52435598/array-from-recursive-promises-returns-undefined\r\n\t * @param  {Number} restaurantId The restaurant to get reviews for\r\n\t * @return {Promise}              promise that will resolve to review json from db\r\n\t */\r\n\tstatic getOperationsToSync(){\r\n\r\n\t\treturn restaurantDb.then(db => {\r\n\t\t\tlet keyVals = [];\r\n\r\n\t\t\tconst tx = db.transaction('unsynced');\r\n\t\t\tconst unsyncedStore = tx.objectStore('unsynced');\r\n\r\n\t\t\tunsyncedStore.iterateCursor(cursor => {\r\n\t\t\t\tif(!cursor) return;\r\n\t\t\t\tconsole.log(`key: ${cursor.primaryKey}, val: ${cursor.value}`);\r\n\t\t\t\tkeyVals.push({key: cursor.primaryKey, value: cursor.value});\r\n\t\t\t\tcursor.continue();\r\n\t\t\t});\r\n\r\n\t\t\treturn tx.complete.then(() => keyVals)\r\n\t\t}).catch(error => {\r\n\t\t\tconsole.error(error);\r\n\t\t});\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * store new or updated review in db\r\n\t * @param  {Json} review Restaurant data in json\r\n\t * @return {Promise}        Resolves if the review is sucessfully updated\r\n\t */\r\n\tstatic storeReview(review){\r\n\t\treturn restaurantDb.then(db => {\r\n\t\t\tconst tx = db.transaction('review', 'readwrite');\r\n\t\t\tconst reviewStore = tx.objectStore('review');\r\n\t\t\treviewStore.put(review);\r\n\t\t\treturn tx.complete;\r\n\t\t}).catch(error => {\r\n\t\t\tconsole.error(error);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * delete restaurant from db\r\n\t * @param  {int} id id of restaurant to delete\r\n\t * @return {Promise}        Resolves if the review is sucessfully updated\r\n\t */\r\n\tstatic deleteReview(id){\r\n\t\treturn restaurantDb.then(db => {\r\n\t\t\tconst tx = db.transaction('review', 'readwrite');\r\n\t\t\tconst reviewStore = tx.objectStore('review');\r\n\t\t\treviewStore.delete(id);\r\n\t\t\treturn tx.complete\r\n\t\t}).catch(error => {\r\n\t\t\tconsole.error(error);\r\n\t\t})\r\n\t}\r\n\r\n\t/**\r\n\t * Store id of unsynced review\r\n\t * @param  {int} id Id of unsynced restaurant\r\n\t * @return {Promise}        Resolves if the review is sucessfully updated\r\n\t */\r\n\tstatic storeOperationToSync(review){\r\n\t\treturn restaurantDb.then(db => {\r\n\t\t\tconst tx = db.transaction('unsynced', 'readwrite');\r\n\t\t\tconst unsyncedStore = tx.objectStore('unsynced');\r\n\t\t\tunsyncedStore.add(review);\r\n\t\t\treturn tx.complete;\r\n\t\t}).catch(error => {\r\n\t\t\tconsole.error(error);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Deletes id with the specified key from unsynced ids\r\n\t * @param  {int} key Key of id to delete\r\n\t * @return {Promise}        Resolves if the review is sucessfully updated\r\n\t */\r\n\tstatic deleteOperationToSync(key){\r\n\t\treturn restaurantDb.then(db => {\r\n\t\t\tconst tx = db.transaction('unsynced', 'readwrite');\r\n\t\t\tconst idStore = tx.objectStore('unsynced');\r\n\t\t\tidStore.delete(key);\r\n\t\t\treturn tx.complete;\r\n\t\t}).catch(error => {\r\n\t\t\tconsole.error(error);\r\n\t\t});\r\n\t}\r\n} "]}